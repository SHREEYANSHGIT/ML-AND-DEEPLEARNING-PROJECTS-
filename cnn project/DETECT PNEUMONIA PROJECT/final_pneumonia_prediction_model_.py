# -*- coding: utf-8 -*-
"""final pneumonia prediction model .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pfF_c12n7kJ6TIeC1u-zycJCDyXg6zoI
"""

import numpy as np
import tensorflow as tf

from tensorflow.keras.utils import image_dataset_from_directory
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.applications.mobilenet_v2 import preprocess_input
from tensorflow.keras import layers, models

from sklearn.utils import class_weight
from sklearn.metrics import confusion_matrix, classification_report

import matplotlib.pyplot as plt

"""# paths of folders and imge sizes, batch

"""

# 1. PATHS â€“ EDIT THESE TO YOUR FOLDERS

train_dir = r"D:\ML,DL,OPENCV ENVN\detect pneumonia PROJECT\chest_xray\chest_xray\train"
val_dir   = r"D:\ML,DL,OPENCV ENVN\detect pneumonia PROJECT\chest_xray\chest_xray\val"
test_dir  = r"D:\ML,DL,OPENCV ENVN\detect pneumonia PROJECT\chest_xray\chest_xray\test"

img_size = (224, 224)
batch_size = 32

print("Train dir:", train_dir)
print("Val dir  :", val_dir)
print("Test dir :", test_dir)

"""# LOAD DATASETS"""

train_ds = image_dataset_from_directory(
    train_dir,
    image_size=img_size,
    batch_size=batch_size,
    label_mode="binary",
    shuffle=True
)

val_ds = image_dataset_from_directory(
    val_dir,
    image_size=img_size,
    batch_size=batch_size,
    label_mode="binary",
    shuffle=False
)

test_ds = image_dataset_from_directory(
    test_dir,
    image_size=img_size,
    batch_size=batch_size,
    label_mode="binary",
    shuffle=False
)

class_names = train_ds.class_names
print("Class names (index 0,1):", class_names)

"""# AUTOTUNING THE MODEL SO THE NEXT BATCH LOAD FASTLY"""

AUTOTUNE = tf.data.AUTOTUNE
train_ds = train_ds.prefetch(AUTOTUNE)
val_ds   = val_ds.prefetch(AUTOTUNE)
test_ds  = test_ds.prefetch(AUTOTUNE)

"""# HANDLE IMBALANCE WITH CLASS WEIGHTS"""

all_labels = []
for _, label in train_ds.unbatch():   # label is scalar
    all_labels.append(int(label.numpy()))

all_labels = np.array(all_labels)
print("Label counts [NORMAL, PNEUMONIA]:", np.bincount(all_labels))

weights = class_weight.compute_class_weight(
    class_weight="balanced",
    classes=np.array([0, 1]),  # 0 -> NORMAL, 1 -> PNEUMONIA
    y=all_labels
)
class_weights = {0: weights[0], 1: weights[1]}
print("Class weights:", class_weights)

"""# BUILD TRANSFER LEARNING CNN (MOBILENETV2 BACKBONE)"""

base_model = MobileNetV2(
    input_shape=img_size + (3,),
    include_top=False,
    weights="imagenet"
)

base_model.trainable = False  # freeze backbone first

"""# TRAIN TOP LAYERS BY CNN"""

inputs = tf.keras.Input(shape=img_size + (3,))
x = preprocess_input(inputs)                 # preprocess for MobileNetV2
x = base_model(x, training=False)           # feature extractor
x = layers.GlobalAveragePooling2D()(x)
x = layers.Dropout(0.3)(x)
outputs = layers.Dense(1, activation="sigmoid")(x)  # binary classification

model = tf.keras.Model(inputs, outputs)

"""# COMPILE THE MODEL"""

optimizer = tf.keras.optimizers.RMSprop(
    learning_rate=1e-4,    # start with lower lr than Adam
    rho=0.9
)

model.compile(
    optimizer=optimizer,
    loss='binary_crossentropy',
    metrics=['accuracy']
)

model.summary()

"""# 5. TRAIN MODEL"""

epochs = 8

history = model.fit(
    train_ds,
    validation_data=val_ds,
    epochs=epochs,
    class_weight=class_weights    # important for imbalance
)

"""# 6. EVALUATE ON TEST SET"""

test_loss, test_acc = model.evaluate(test_ds)
print("\nTest accuracy:", test_acc)

"""# 7. PLOT TRAINING CURVES"""

acc = history.history["accuracy"]
val_acc = history.history["val_accuracy"]
loss = history.history["loss"]
val_loss = history.history["val_loss"]
epochs_range = range(1, len(acc) + 1)

plt.figure()
plt.plot(epochs_range, acc, label="Train Acc")
plt.plot(epochs_range, val_acc, label="Val Acc")
plt.xlabel("Epoch")
plt.ylabel("Accuracy")
plt.legend()
plt.title("Accuracy")
plt.show()

plt.figure()
plt.plot(epochs_range, loss, label="Train Loss")
plt.plot(epochs_range, val_loss, label="Val Loss")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.title("Loss")
plt.show()

"""# 8. CONFUSION MATRIX ON TEST SET"""

y_true = []
y_pred = []

for images, labels in test_ds:
    probs = model.predict(images).reshape(-1)  # prob for class index 1 (PNEUMONIA)
    preds = (probs > 0.5).astype(int)
    y_true.extend(labels.numpy().astype(int))
    y_pred.extend(preds)

y_true = np.array(y_true)
y_pred = np.array(y_pred)

print("\nConfusion matrix (rows=true, cols=pred):")
print(confusion_matrix(y_true, y_pred))

print("\nClassification report:")
print(classification_report(y_true, y_pred, target_names=class_names, digits=4))

"""# 9. PREPARE IMAGE FOR PREDICTION"""

def prepare_image(img_path):
    img = image.load_img(img_path, target_size=img_size)
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = preprocess_input(img_array)
    return img_array, img

"""# 10. USER INPUT IMAGE PREDICTION"""

import os
single_img_path = r"D:\ML,DL,OPENCV ENVN\detect pneumonia PROJECT\chest_xray\chest_xray\test\NORMAL\NORMAL2-IM-0029-0001.jpeg"

if os.path.exists(single_img_path):
    img_data, img_vis = prepare_image(single_img_path)
    prob = model.predict(img_data)[0][0]   # probability of class 'PNEUMONIA' (index 1)

    neg_class = class_names[0]  # 'NORMAL'
    pos_class = class_names[1]  # 'PNEUMONIA'

    pred_label = pos_class if prob > 0.5 else neg_class

    print(f"\nSingle image: {single_img_path}")
    print("Raw probability (PNEUMONIA):", prob)
    print("Predicted label:", pred_label)

    plt.imshow(img_vis)
    plt.axis("off")
    plt.title(f"Prediction: {pred_label} ({prob:.3f})")
    plt.show()
else:
    print(f"\nSingle image path does not exist: {single_img_path}")

"""# 11. SHOW 10 SAMPLE IMAGES FROM TEST SET WITH PRED + TRUE"""

print("\n10 sample predictions from test set with images:")

import matplotlib.pyplot as plt

for images, labels in test_ds.take(1):  # take 1 batch
    probs = model.predict(images).reshape(-1)
    num_samples = min(10, len(probs))

    for i in range(num_samples):
        prob = probs[i]
        pred_idx = int(prob > 0.5)
        true_idx = int(labels[i].numpy())

        pred_label = class_names[pred_idx]
        true_label = class_names[true_idx]

        print(
            f"Sample {i}: prob={prob:.3f}, "
            f"pred={pred_label}, true={true_label}"
        )

        plt.figure(figsize=(3, 3))
        # images[i] is still in [0,255] range, show directly
        plt.imshow(images[i].numpy().astype("uint8"))
        plt.axis("off")
        plt.title(f"Pred: {pred_label} ({prob:.3f})\nTrue: {true_label}")
        plt.show()